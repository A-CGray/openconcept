"""Analysis routines for simulating thermal management of aircraft components"""
from __future__ import division
from openmdao.api import Problem, Group, IndepVarComp
from openmdao.api import ScipyOptimizeDriver, ExplicitComponent, ImplicitComponent

import numpy as np
import scipy.sparse as sp

from openconcept.utilities.math.simpson_integration import simpson_integral, simpson_partials, simpson_integral_every_node, simpson_partials_every_node, IntegrateQuantity
from openconcept.utilities.math.derivatives import FirstDerivative
from openconcept.utilities.math import AddSubtractComp, ElementMultiplyDivideComp, VectorConcatenateComp, VectorSplitComp


class CoolantLoopStation(ImplicitComponent):
    """
    Computes a thermal residual based on upstream temperature for a closed circuit coolant loop

    Inputs
    ------
    temp_in : float
        Fluid temperature at upstream station (vector, K)
    q_in : float
        Heat recieved by the fluid stream - positive means adding heat (vector, W)
    mdot : float
        Coolant mass flow rate (vector, kg/s)

    Outputs
    -------
    temp_out : float
        Fluid temperature downstream of the station (vector, K)

    Options
    -------
    specific_heat : float
        Specific heat capacity of the fluid in J / kg / K (default 3391.3 = 60 pct ethylene glycol 40pct water)
        TODO model change in specific heat as a function of temperature. it is quite substantial.
    n_int_per_seg : int
        Number of Simpson's rule intervals to use per mission segment.
        The total number of points is 2 * n_int_per_seg + 1
    mission_segments : list
        The list of mission segments to track

    """
    def initialize(self):
        self.options.declare('n_int_per_seg',default=5,desc="Number of Simpson intervals to use per seg (eg. climb, cruise, descend). Number of analysis points is 2N+1")
        self.options.declare('mission_segments', default=['climb','cruise','descent'])
        self.options.declare('specific_heat', default=3391.3, desc='Specific heat in J/kg/K')

    def setup(self):
        n_int_per_seg = self.options['n_int_per_seg']
        nn = (n_int_per_seg*2 + 1)
        mission_segment_names = self.options['mission_segments']
        n_seg = len(mission_segment_names)
        nn_tot = nn * n_seg
        arange = np.arange(0, nn_tot)

        self.add_input('q_in', units='W', shape=(nn_tot,))
        self.add_input('temp_in', units='K', shape=(nn_tot,))
        self.add_input('mdot', units='kg/s', shape=(nn_tot,))
        self.add_output('temp_out', units='K', shape=(nn_tot,))

        self.declare_partials(['temp_out'], ['q_in'], rows=arange, cols=arange, val=np.ones((nn_tot,)))
        self.declare_partials(['temp_out'], ['mdot', 'temp_in','temp_out'], rows=arange, cols=arange)

    def apply_nonlinear(self, inputs, outputs, residuals):
        spec_heat = self.options['specific_heat']
        residuals['temp_out'] = inputs['q_in'] - inputs['mdot'] * spec_heat * (outputs['temp_out'] - inputs['temp_in'])

    def linearize(self, inputs, outputs, J):
        spec_heat = self.options['specific_heat']
        J['temp_out','mdot'] = - spec_heat * (outputs['temp_out'] - inputs['temp_in'])
        J['temp_out','temp_out'] = - inputs['mdot'] * spec_heat
        J['temp_out','temp_in'] = inputs['mdot'] * spec_heat


class ThermalComponentBase(ImplicitComponent):
    """
    Computes thermal residual of a component with heating, cooling, and thermal mass

    Inputs
    ------
    q_in : float
        Heat generated by the component (vector, W)
    q_out : float
        Heat to waste stream (vector, W)
    mass : float
        Thermal mass (scalar, kg)

    Outputs
    -------
    dTdt : float
        First derivative of temperature (vector, K/s)

    Options
    -------
    specific_heat : float
        Specific heat capacity of the object in J / kg / K (default 921 = aluminum)
    n_int_per_seg : int
        Number of Simpson's rule intervals to use per mission segment.
        The total number of points is 2 * n_int_per_seg + 1
    mission_segments : list
        The list of mission segments to track

    """
    def initialize(self):
        self.options.declare('n_int_per_seg',default=5,desc="Number of Simpson intervals to use per seg (eg. climb, cruise, descend). Number of analysis points is 2N+1")
        self.options.declare('mission_segments', default=['climb','cruise','descent'])
        self.options.declare('specific_heat', default=921.0, desc='Specific heat in J/kg/K')

    def setup(self):
        n_int_per_seg = self.options['n_int_per_seg']
        nn = (n_int_per_seg*2 + 1)
        mission_segment_names = self.options['mission_segments']
        n_seg = len(mission_segment_names)
        nn_tot = nn * n_seg
        arange = np.arange(0, nn_tot)

        self.add_input('q_in', units='W', shape=(nn_tot,))
        self.add_input('q_out', units='W', shape=(nn_tot,))
        self.add_input('mass', units='kg')
        self.add_output('dTdt', units='K/s', shape=(nn_tot,))

        self.declare_partials(['dTdt'], ['q_in'], rows=arange, cols=arange, val=np.ones((nn_tot,)))
        self.declare_partials(['dTdt'], ['q_out'], rows=arange, cols=arange, val=-np.ones((nn_tot,)))
        self.declare_partials(['dTdt'], ['mass'], rows=arange, cols=np.zeros((nn_tot,)))
        self.declare_partials(['dTdt'], ['dTdt'], rows=arange, cols=arange)

    def apply_nonlinear(self, inputs, outputs, residuals):
        spec_heat = self.options['specific_heat']
        residuals['dTdt'] = inputs['q_in'] - inputs['q_out'] - inputs['mass']*inputs['dTdt']*spec_heat

    def linearize(self, inputs, outputs, J):
        n_int_per_seg = self.options['n_int_per_seg']
        nn = (n_int_per_seg*2 + 1)
        mission_segment_names = self.options['mission_segments']
        n_seg = len(mission_segment_names)
        nn_tot = nn * n_seg
        spec_heat = self.options['specific_heat']
        J['dTdt','mass'] = - inputs['dTdt']*spec_heat
        J['dTdt','dTdt'] = - inputs['mass']*spec_heat*np.ones((nn_tot,))


class ConstantSurfaceTemperatureColdPlate(ExplicitComponent):
    def initialise(self):
        self.options.declare('n_int_per_seg',default=5,desc="Number of Simpson intervals to use per seg (eg. climb, cruise, descend). Number of analysis points is 2N+1")
        self.options.declare('mission_segments', default=['climb','cruise','descent'])
        self.options.declare('fluid_rho', default=997.0, desc='Fluid density in kg/m3')
        self.options.declare('fluid_k', default=0.6, desc='Thermal conductivity of the fluid in W / mK')
        self.options.declare('nusselt', default=7.54, desc='Hydraulic diameter Nusselt number')

    def setup(self):
        n_int_per_seg = self.options['n_int_per_seg']
        nn = (n_int_per_seg*2 + 1)
        mission_segment_names = self.options['mission_segments']
        n_seg = len(mission_segment_names)
        nn_tot = nn * n_seg
        arange = np.arange(0, nn_tot)

        self.add_input('T_in', units='K', shape=(nn_tot,))
        self.add_input('T_out', units='K', shape=(nn_tot,))
        self.add_input('T_surface', units='K', shape=(nn_tot,))
        self.add_input('channel_width', units='m')
        self.add_input('channel_height', units='m')
        self.add_input('channel_length', units='m')
        self.add_input('n_parallel')

        self.add_output('q', units='W', shape=(nn_tot,))

        self.declare_partials(['q'], ['T_in','T_out','T_surface'], rows=arange, cols=arange)
        self.declare_partials(['q'], ['channel_width','channel_height','channel_length','n_parallel'], rows=arange, cols=np.zeros((nn_tot), dtype=np.int32))

    def compute(self, inputs, outputs):
        Ts = inputs['T_surface']
        Ti = inputs['T_in']
        To = inputs['T_out']
        log_mean_temp_diff = (Ti - To) / np.log((Ts-To)/(Ts-Ti))

        #cross_section_area = inputs['channel_width'] * inputs['channel_height'] * inputs['n_parallel']
        #flow_rate = inputs['mdot'] / self.options['rho'] / cross_section_area # m/s
        surface_area = 2 * inputs['channel_height'] * inputs['channel_length'] * inputs['n_parallel']
        d_h = 2 * inputs['channel_width']

        h = self.options['nusselt'] * self.options['fluid_k'] / dh

        outputs['q'] = h * surface_area * log_mean_temp_diff


    def compute_partials(self, inputs, J):
        Ts = inputs['T_surface']
        Ti = inputs['T_in']
        To = inputs['T_out']
        log_mean_temp_diff = (Ti - To) / np.log((Ts-To)/(Ts-Ti))

        #cross_section_area = inputs['channel_width'] * inputs['channel_height'] * inputs['n_parallel']
        #flow_rate = inputs['mdot'] / self.options['rho'] / cross_section_area # m/s
        surface_area = 2 * inputs['channel_height'] * inputs['channel_length'] * inputs['n_parallel']
        d_h = 2 * inputs['channel_width']

        h = self.options['nusselt'] * self.options['fluid_k'] / dh

        outputs['q'] = h * surface_area * log_mean_temp_diff

        J['q', 'channel_width'] = - log_mean_temp_diff * surface_area * h / d_h * 2
        J['q', 'channel_height'] = log_mean_temp_diff * h * 2 * inputs['channel_length'] * inputs['n_parallel']
        J['q', 'channel_length'] = log_mean_temp_diff * h * 2 * inputs['channel_height'] * inputs['n_parallel']
        J['q', 'n_parallel'] = log_mean_temp_diff * h * 2 * inputs['channel_height'] * inputs['channel_length']

        #LMTD partials
        logdelta = np.log((Ts-To)/(Ts-Ti))
        J['q', 'T_out'] = h * surface_area * ((Ti-To)/(Ts-To)/logdelta**2 - 1/logdelta)
        J['q', 'T_in'] = h * surface_area * ((Ti-To)/(Ti-Ts) + logdelta) / logdelta**2
        J['q', 'T_surface'] = - h * surface_area * (Ti-To)**2 / (Ti-Ts)/(Ts-To)/logdelta**2